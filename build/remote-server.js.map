{"version":3,"file":"remote-server.js","sourceRoot":"/","sources":["remote-server.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { EventEmitter } from 'events';\n\nimport {\n  createServer,\n  Server,\n  Socket,\n} from 'net';\n/**\n *  Class for the server to handle remote sensors.\n */\n\nimport { autobind } from 'core-decorators';\n\nimport { Ds18b20Adapter } from './main';\nimport { decrypt, encrypt } from './common/crypt';\n\nimport { RemoteData } from './common/types';\n\n/**\n * Information about a connected client.\n */\ninterface RemoteClient {\n  socket: Socket;\n  systemId: string;\n}\n\nexport class RemoteSensorServer extends EventEmitter {\n\n  private adapter: Ds18b20Adapter;\n  private encyptionKey: Buffer;\n\n  private server: Server;\n\n  private sockets: Record<string, RemoteClient> = {};\n  private socketTimeouts: Record<string, NodeJS.Timeout> = {};\n\n  constructor (port: number, encKey: string, adapter: Ds18b20Adapter) {\n    super();\n\n    this.encyptionKey = Buffer.from(encKey, 'hex');\n    this.adapter = adapter;\n\n    this.server = createServer();\n\n    this.server.on('connection', this.handleConnection);\n\n    this.server.on('error', (err: Error) => {\n      this.emit('error', err);\n    });\n\n    this.server.listen(port, () => {\n      this.emit('listening');\n    });\n  }\n\n  public isListening (): boolean {\n    return this.server && this.server.listening;\n  }\n\n  public getConnectedSystems (): string[] {\n    const systems: string[] = [];\n    for (const socketId in this.sockets) {\n      systems.push(this.sockets[socketId].systemId);\n    }\n    return systems;\n  }\n\n  public async read (clientSystemId: string, sensorAddress: string): Promise<void> {\n    // get the socket\n    let client: RemoteClient | null = null;\n    for (const socketId in this.sockets) {\n      if (this.sockets[socketId].systemId === clientSystemId) {\n        client = this.sockets[socketId];\n        break;\n      }\n    }\n\n    if (!client) {\n      // client not connected\n      this.adapter.log.warn(`No remote client ${clientSystemId} is not connected.`);\n      throw new Error('Client not connected');\n    }\n\n    await this.send(client.socket, {\n      cmd: 'read',\n      address: sensorAddress,\n    });\n\n    // TODO: handle the response for callback functions\n  }\n\n  public stop (): Promise<void> {\n    return new Promise<void>((resolve) => {\n      this.server.close(() => resolve());\n    });\n  }\n\n  @autobind\n  private handleConnection (socket: Socket): void {\n    const socketId = `${socket.remoteAddress}:${socket.remotePort}`;\n    this.adapter.log.debug(`socket connect ${socketId}`);\n\n    socket.on('close', () => {\n      this.adapter.log.debug(`socket closed ${socketId}`);\n      if (this.sockets[socketId]) {\n        this.adapter.log.info(`Remote client ${this.sockets[socketId].systemId} (${socketId}) disconnected`);\n      } else {\n        this.adapter.log.info(`Remote client ${socketId} disconnected`);\n      }\n      delete this.sockets[socketId];\n    });\n\n    // collect all incoming data and split it by `\\n`\n    let dataStr = '';\n    socket.on('data', (data: Buffer) => {\n      dataStr += data.toString();\n\n      const idx = dataStr.indexOf('\\n');\n      if (idx > 0) {\n        const raw = dataStr.slice(0, idx);\n        dataStr = dataStr.slice(idx+1);\n        this.handleSocketData(socketId, socket, raw);\n      }\n    });\n\n    // set timeout to close unknown sockets after 5 seconds\n    this.socketTimeouts[socketId] = setTimeout(() => {\n      this.adapter.log.warn(`Disconnection remote ${socketId} due to inactivity`);\n      socket.destroy();\n      delete this.socketTimeouts[socketId];\n    }, 5000);\n\n    // request client information\n    this.send(socket, { cmd: 'clientInfo' });\n  }\n\n  private handleSocketData (socketId: string, socket: Socket, raw: string): void {\n\n    // try to decrypt and parse the data\n    let data: RemoteData;\n    try {\n      const dataStr = decrypt(raw, this.encyptionKey);\n      data = JSON.parse(dataStr);\n    } catch (err) {\n      this.adapter.log.warn(`Decrypt of data from ${socketId} failed! ${err.toString()}`);\n      // close the socket\n      socket.destroy();\n      return;\n    }\n\n    this.adapter.log.debug(`data from remote ${socketId}: ${JSON.stringify(data)}`);\n\n    switch (data.cmd) {\n      case 'clientInfo':\n        // got client information\n        if (!data.systemId) {\n          this.adapter.log.warn(`Got invalid data from remote ${socketId}!`);\n          return;\n        }\n\n        // clear the close timeout\n        clearTimeout(this.socketTimeouts[socketId]);\n        delete this.socketTimeouts[socketId];\n\n        // save as known socket\n        this.sockets[socketId] = {\n          socket: socket,\n          systemId: data.systemId,\n        };\n\n        this.adapter.log.info(`Remote client ${data.systemId} connected from ${socket.remoteAddress}`);\n        break;\n\n      case 'read':\n        // got sensor data\n        const sensor = this.adapter.getSensor(data.address);\n        if (!sensor) {\n          this.adapter.log.warn(`Got remote data for unknown sensor ${data.address}.`);\n          return;\n        }\n\n        sensor.processData(data.raw || '');\n\n      case 'search':\n        // got search data\n\n\n      default:\n        this.adapter.log.warn(`Unknown command \"${data.cmd}\" from client ${socketId}.`);\n    }\n  }\n\n  private async send (socket: Socket, data: RemoteData): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      socket.write(encrypt(JSON.stringify(data), this.encyptionKey) + '\\n', (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    })\n  }\n}"]}