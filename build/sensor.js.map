{
  "version": 3,
  "sources": ["../src/sensor.ts"],
  "sourcesContent": ["/**\n *  Class for a DS18B20 temperature sensor.\n */\n\nimport { EventEmitter } from 'events';\nimport { promisify } from 'util';\n\nimport * as fs from 'fs';\nconst readFile = promisify(fs.readFile);\n\nimport { boundMethod } from 'autobind-decorator';\n\nimport { round } from './lib/utils';\nimport type { Ds18b20Adapter } from './main';\n\n/**\n * Options for a Sensor.\n */\ninterface SensorOptions {\n  w1DevicesPath: string;\n  id: string;\n  address: string;\n  interval: number;\n  nullOnError: boolean;\n  factor: number;\n  offset: number;\n  decimals: number | null;\n\n  remoteSystemId: string | null;\n}\n\n/**\n * Interface to declare events for the Sensor class.\n */\nexport interface Sensor {\n  on (event: 'value', listener: (value: number | null, id: string) => void): this;\n  on (event: 'error', listener: (err: Error, id: string) => void): this;\n  on (event: 'errorStateChanged', listener: (hasError: boolean, id: string) => void): this;\n\n  emit (event: 'value', value: number | null, id: string): boolean;\n  emit (event: 'error', err: Error, id: string): boolean;\n  emit (event: 'errorStateChanged', hasError: boolean, id: string): boolean;\n}\n\n/**\n * This class represents a single sensor.\n */\nexport class Sensor extends EventEmitter {\n  /**\n   * The ID of the sensor in ioBroker.\n   */\n  public readonly id: string;\n\n  /**\n   * The address (1-wire ID) of the sensor.\n   */\n  public readonly address: string;\n\n  /**\n   * Use null values on errors.\n   */\n  public readonly nullOnError: boolean;\n\n  /**\n   * Factor for value calculation.\n   */\n  public readonly factor: number;\n\n  /**\n   * Offset for value calculation.\n   */\n  public readonly offset: number;\n\n  /**\n   * Number of decimals to round to.\n   */\n  public readonly decimals: number | null;\n\n  /**\n   * SystemID of the client with this sensor if this is a remote sensor.\n   * `null` for local sensors.\n   */\n  public readonly remoteSystemId: string | null;\n\n  /**\n   * Flag if the last read of the sensor had an error.\n   */\n  public hasError: boolean;\n\n  /**\n   * Timer for interval sensor readings.\n   */\n  private timer: ioBroker.Interval | null = null;\n\n  /**\n   * System path where the 1-wire devices can be read.\n   */\n  private readonly w1DevicesPath: string;\n\n  /**\n   * Reference to the adapter class.\n   */\n  private readonly adapter: Ds18b20Adapter;\n\n  /**\n   * Constructor for a new sensor.\n   * @param opts The options for the Sensor.\n   */\n  constructor (opts: SensorOptions, adapter: Ds18b20Adapter) {\n    super();\n    this.adapter = adapter;\n\n    this.id = opts.id;\n    this.address = opts.address.replace(/[^0-9a-f-]/g, ''); // remove all bad chars!\n    this.nullOnError = opts.nullOnError;\n    this.factor = opts.factor;\n    this.offset = opts.offset;\n    this.decimals = opts.decimals;\n    this.hasError = true; // true on init while we don't know the current state\n    this.w1DevicesPath = opts.w1DevicesPath;\n    this.remoteSystemId = opts.remoteSystemId;\n\n    // start interval and initial read if interval is set\n    if (opts.interval && opts.interval > 0) {\n      // smallest interval is 500ms\n      if (opts.interval < 500) {\n        opts.interval = 500;\n      }\n      this.timer = this.adapter.setInterval(this.read, opts.interval);\n      this.read();\n    }\n  }\n\n  /**\n   * Read the temperature.\n   * The value and possible errors will be emitted as events.\n   * Optionally a callback may be used.\n   * @param  cb Optional callback function.\n   */\n  @boundMethod\n  public async read (cb?: (err: Error | null, val: number | null) => void): Promise<void> {\n\n    try {\n      let raw: string;\n\n      if (this.remoteSystemId) {\n        // remote sensor - send request\n        if (!this.adapter.remoteSensorServer) {\n          throw new Error('Remote sensors not enabled');\n        }\n        raw = await this.adapter.remoteSensorServer.read(this.remoteSystemId, this.address);\n      } else {\n        // local sensor - read the file\n        raw = await readFile(`${this.w1DevicesPath}/${this.address}/w1_slave`, 'utf8');\n      }\n\n      this.processData(raw, cb);\n\n    } catch (err: any) {\n      this.emit('error', err, this.id);\n      if (typeof cb === 'function') {\n        cb(err, null);\n      }\n    }\n  }\n\n  /**\n   * Process the raw data from a sensor file.\n   * @param rawData The raw data read from the sensor file.\n   * @param cb Optional callback function.\n   */\n  public async processData (rawData: string, cb?: (err: Error | null, val: number | null) => void): Promise<void> {\n    const lines = rawData.split('\\n');\n\n    let val: number | null = null;\n    let err: Error | null = null;\n\n    try {\n      if (lines[0].indexOf('YES') > -1) {\n        // checksum ok\n        const bytes = lines[0].split(' ');\n        if (bytes[0] === bytes[1] && bytes[0] === bytes[2] && bytes[0] === bytes[3] && bytes[0] === bytes[4] && bytes[0] === bytes[5] && bytes[0] === bytes[6] && bytes[0] === bytes[7] && bytes[0] === bytes[8]) {\n          // all bytes are the same\n          throw new Error('Communication error');\n        }\n\n        const m = lines[1].match(/t=(-?\\d+)/);\n        if (!m) {\n          throw new Error('Parse error');\n        }\n        val = parseInt(m[1], 10) / 1000;\n\n      } else if (lines[0].indexOf('NO') > -1) {\n        // checksum error\n        throw new Error('Checksum error');\n\n      } else {\n        // read error\n        throw new Error('Read error');\n      }\n\n      // check for specific errors\n      if (val === 85) {\n        throw new Error('No temperature read');\n      } else if (val === -127) {\n        throw new Error('Device disconnected');\n      } else if (val < -80 || val > 150) {\n        // From datasheet: Measures Temperatures from -55\u00B0C to +125\u00B0C\n        throw new Error('Read temperature is out of possible range');\n      }\n\n    } catch (e: any) {\n      this.emit('error', e, this.id);\n      err = e;\n      val = null;\n    }\n\n    // evaluate the result\n    if (val !== null) {\n      val = val * this.factor + this.offset;\n      if (this.decimals !== null) {\n        val = round(val, this.decimals);\n      }\n    }\n\n    if (val !== null || this.nullOnError) {\n      this.emit('value', val, this.id);\n    }\n\n    if (this.hasError !== (val === null)) {\n      this.hasError = (val === null);\n      this.emit('errorStateChanged', this.hasError, this.id);\n    }\n\n    if (typeof cb === 'function') {\n      cb(err, val);\n    }\n  }\n\n  /**\n   * Stop a running interval for automated readings.\n   */\n  public stop (): void {\n    if (this.timer) {\n      this.adapter.clearInterval(this.timer);\n      this.timer = null;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
