{"version":3,"file":"sensor.js","sourceRoot":"/","sources":["sensor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n *  Class for a DS18B20 temperature sensor.\n */\n\nimport { EventEmitter } from 'events';\nimport { promisify } from 'util';\n\nimport * as fs from 'fs';\nconst readFile = promisify(fs.readFile);\n\nimport { autobind } from 'core-decorators';\n\nimport { round } from './lib/tools';\n\n/**\n * Options for a Sensor.\n */\ninterface SensorOptions {\n  w1DevicesPath: string;\n  id: string;\n  address: string;\n  interval: number;\n  nullOnError: boolean;\n  factor: number;\n  offset: number;\n  decimals: number | null;\n}\n\n/**\n * Interface to declare events for the Sensor class.\n */\nexport interface Sensor {\n  on (event: 'value', listener: (value: number | null, id: string) => void): this;\n  on (event: 'error', listener: (err: Error, id: string) => void): this;\n  on (event: 'errorStateChanged', listener: (hasError: boolean, id: string) => void): this;\n\n  emit (event: 'value', value: number | null, id: string): boolean;\n  emit (event: 'error', err: Error, id: string): boolean;\n  emit (event: 'errorStateChanged', hasError: boolean, id: string): boolean;\n}\n\n/**\n * This class represents a single sensor.\n */\nexport class Sensor extends EventEmitter {\n  /**\n   * The ID of the sensor in ioBroker.\n   */\n  public readonly id: string;\n\n  /**\n   * The address (1-wire ID) of the sensor.\n   */\n  public readonly address: string;\n\n  /**\n   * Use null values on errors.\n   */\n  public readonly nullOnError: boolean;\n\n  /**\n   * Factor for value calculation.\n   */\n  public readonly factor: number;\n\n  /**\n   * Offset for value calculation.\n   */\n  public readonly offset: number;\n\n  /**\n   * Number of decimals to round to.\n   */\n  public readonly decimals: number | null;\n\n  /**\n   * Flag if the last read of the sensor had an error.\n   */\n  public hasError: boolean;\n\n  /**\n   * Timer for interval sensor readings.\n   */\n  private timer: number | null = null;\n\n  /**\n   * System path where the 1-wire devices can be read.\n   */\n  private readonly w1DevicesPath: string;\n\n  /**\n   * Constructor for a new sensor.\n   * @param opts The options for the Sensor.\n   */\n  constructor (opts: SensorOptions) {\n    super();\n    this.id = opts.id;\n    this.address = opts.address.replace(/[^0-9a-f-]/g, ''); // remove all bad chars!\n    this.nullOnError = opts.nullOnError;\n    this.factor = opts.factor;\n    this.offset = opts.offset;\n    this.decimals = opts.decimals;\n    this.hasError = true; // true on init while we don't know the current state\n    this.w1DevicesPath = opts.w1DevicesPath;\n\n    // start interval and inital read if interval is set\n    if (opts.interval && opts.interval > 0) {\n      // smallest interval is 500ms\n      if (opts.interval < 500) {\n        opts.interval = 500;\n      }\n      this.timer = setInterval(this.read, opts.interval);\n      this.read();\n    }\n  }\n\n  /**\n   * Read the temperature.\n   * The value and possible errors will be emitted as events.\n   * Optionally a callback may be used.\n   * @param  cb Optional callback function.\n   */\n  @autobind\n  public read (cb?: (err: Error | null, val: number | null) => void): void {\n    // read the file\n    readFile(`${this.w1DevicesPath}/${this.address}/w1_slave`, 'utf8')\n      // process data\n      .then((data: string) => {\n        const lines = data.split('\\n');\n\n        if (lines[0].indexOf('YES') > -1) {\n          // checksum ok\n          const bytes = lines[0].split(' ');\n          if (bytes[0] === bytes[1] && bytes[0] === bytes[2] && bytes[0] === bytes[3] && bytes[0] === bytes[4] && bytes[0] === bytes[5] && bytes[0] === bytes[6] && bytes[0] === bytes[7] && bytes[0] === bytes[8]) {\n            // all bytes are the same\n            throw new Error('Communication error');\n          }\n\n          const m = lines[1].match(/t=(-?\\d+)/);\n          if (!m) {\n            throw new Error('Parse error');\n          }\n          return parseInt(m[1], 10) / 1000;\n\n        } else if (lines[0].indexOf('NO') > -1) {\n          // checksum error\n          throw new Error('Checksum error');\n\n        } else {\n          // read error\n          throw new Error('Read error');\n\n        }\n      })\n\n      // check for specific errors\n      .then((val) => {\n        switch (val) {\n          case 85:   throw new Error('No temperature read');\n          case -127: throw new Error('Device disconnected');\n          default:   return { err: null, val: val };\n        }\n      })\n\n      // handle errors\n      .catch((err: Error) => {\n        this.emit('error', err, this.id);\n        return { err: err, val: null };\n      })\n\n      // evaluate the result\n      .then((data: { err: Error|null; val: number|null }) => {\n        if (data.val !== null) {\n          data.val = data.val * this.factor + this.offset;\n          if (this.decimals !== null) {\n            data.val = round(data.val, this.decimals);\n          }\n        }\n\n        if (data.val !== null || this.nullOnError) {\n          this.emit('value', data.val, this.id);\n        }\n\n        if (this.hasError !== (data.val === null)) {\n          this.hasError = (data.val === null);\n          this.emit('errorStateChanged', this.hasError, this.id);\n        }\n\n        if (typeof cb === 'function') {\n          cb(data.err, data.val);\n        }\n      });\n  }\n\n  /**\n   * Stop a running interval for automated readings.\n   */\n  public stop (): void {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n  }\n}\n"]}