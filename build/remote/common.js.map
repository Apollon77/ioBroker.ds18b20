{"version":3,"file":"common.js","sourceRoot":"/","sources":["remote/common.ts"],"names":[],"mappings":";;;AAIA,iCAAiC;AAMpB,QAAA,uBAAuB,GAAG,CAAC,CAAC;AAMzC,MAAM,SAAS,GAAG,EAAE,CAAC;AAQrB,SAAgB,OAAO,CAAE,IAAuB,EAAE,GAAW;IAC3D,MAAM,EAAE,GAAG,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;IACzC,MAAM,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;IAC7D,IAAI,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAEpC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,CAAE,SAAS,EAAE,MAAM,CAAC,KAAK,EAAE,CAAE,CAAC,CAAC;IAEzD,OAAO,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC9D,CAAC;AARD,0BAQC;AAQD,SAAgB,OAAO,CAAE,IAAY,EAAE,GAAW;IAChD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAClC,MAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAY,EAAE,KAAK,CAAC,CAAC;IAC3D,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;IAC9D,MAAM,QAAQ,GAAG,MAAM,CAAC,gBAAgB,CAAC,aAAa,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;IACjE,IAAI,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;IAE/C,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,CAAE,SAAS,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAE,CAAC,CAAC;IAE3D,OAAO,SAAS,CAAC,QAAQ,EAAE,CAAC;AAC9B,CAAC;AAVD,0BAUC","sourcesContent":["/*\n * Common functions and constants used by the adapter and the remote client.\n */\n\nimport * as crypto from 'crypto';\n\n/**\n * Protocol version for the communication.\n * May change in future versions.\n */\nexport const REMOTE_PROTOCOL_VERSION = 1;\n\n/**\n * Length of the initialization vector for encryption.\n * For AES, this is always 16.\n */\nconst IV_LENGTH = 16;\n\n/**\n * Encrypt a string with the given key.\n * @param text The string to encrypt.\n * @param key The key to use.\n * @throws An error if the key has not 32 bytes.\n */\nexport function encrypt (text: crypto.BinaryLike, key: Buffer): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  let encrypted = cipher.update(text);\n\n  encrypted = Buffer.concat([ encrypted, cipher.final() ]);\n\n  return iv.toString('hex') + ':' + encrypted.toString('hex');\n}\n\n/**\n * Decrypt an encrypted string with the given key.\n * @param text The encrypted string to decrypt.\n * @param key The key to use.\n * @throws An error if the key has not 32 bytes isn't valid.\n */\nexport function decrypt (text: string, key: Buffer): string {\n  const textParts = text.split(':');\n  const iv = Buffer.from(textParts.shift() as string, 'hex');\n  const encryptedText = Buffer.from(textParts.join(':'), 'hex');\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n  let decrypted = decipher.update(encryptedText);\n\n  decrypted = Buffer.concat([ decrypted, decipher.final() ]);\n\n  return decrypted.toString();\n}\n"]}